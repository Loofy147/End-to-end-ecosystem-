# attention_es_large.py
# نسخة جاهزة للتشغيل على Colab / جهاز قوي
import numpy as np, pandas as pd, matplotlib.pyplot as plt, time, os
np.random.seed(123)

# ---------- تعديل سريع للمعلمات (اضبط هنا) ----------
N = 800                # حجم النظام الكبير المطلوب (ابدأ بـ 200-800 على Colab Pro)
T = 800                # عدد الخطوات الزمنية
alpha = 0.34
init_eta = 0.06
init_lambda = 0.012
noise_sigma = 0.03
energy_cost_per_weight = 1.0
init_gate_topk = 16
intervene_every = 25
es_population = 12
probe_steps = 6
audit_strength = 0.5
malicious_frac = 0.05
w_S = 1.0
w_energy = 0.0045
# -------------------------------------------------------

# ---------- دوال مساعدة (مؤثّرة على الأداء؛ حافظ عليها مُوجزة) ----------
eps = 1e-12
def aggregate_inputs(A, b):
    return (A.T.dot(b)) / (A.sum(axis=0) + eps)

def update_states(b, I, alpha, sigma):
    noise = np.random.normal(0, sigma, size=b.shape)
    return np.tanh((1-alpha)*b + alpha*I + noise)

def compute_S(b): return max(-1.0, 1.0 - np.var(b))
def energy_of_A(A): return energy_cost_per_weight * A.sum()

def apply_gating(A, topk):
    # حفاظًا على الأداء نستخدم argpartition لكل صف
    if topk >= A.shape[1]: return A.copy()
    A2 = np.zeros_like(A)
    for i in range(A.shape[0]):
        row = A[i]
        if row.sum() <= 0: continue
        k = min(topk, row.size)
        idxs = np.argpartition(-row, k-1)[:k]
        A2[i, idxs] = row[idxs]
    return A2
# -------------------------------------------------------

# ---------- التهيئة ----------
b = np.random.uniform(-1, 1, size=N)
A = np.abs(np.random.normal(loc=0.018, scale=0.006, size=(N, N)))
np.fill_diagonal(A, 0.0)
# إضافة هيكل عنقودي (اختياري لكنه يجعل السلوك مثيرًا للاختبار)
num_clusters = max(4, N//150)
cluster_assign = np.random.randint(0, num_clusters, size=N)
cluster_eq = (cluster_assign[:, None] == cluster_assign[None, :]).astype(float)
A += 0.028 * cluster_eq
A = np.maximum(A, 0.0)
malicious_idx = np.random.choice(np.arange(N), size=max(1,int(N*malicious_frac)), replace=False)

ctrl = {'eta': init_eta, 'lambda': init_lambda, 'gate_topk': init_gate_topk}
es_sigma = {'eta': 0.02, 'lambda': 0.006, 'gate_topk': 3.0}

records = []
start_time = time.time()
# ---------- الحلقة الرئيسية ----------
for t in range(T):
    A_gated = apply_gating(A, int(round(ctrl['gate_topk'])))
    I = aggregate_inputs(A_gated, b)
    # هجوم خبيث دوري (اختياري)
    if t % 30 == 0 and t>0:
        mal_influence = (A_gated.T[:, malicious_idx].sum(axis=1) * 0.16)
        I = I + mal_influence * (np.mean(b[malicious_idx]) * -0.36)
    b_new = update_states(b, I, alpha, noise_sigma)
    local_gain = np.tanh(np.abs(b_new - b))
    sim_mat = 1.0 - np.abs(b[:, None] - b[None, :])
    sim_mat = np.clip(sim_mat, 0.0, 1.0)
    reward_mat = sim_mat * local_gain[None, :]
    A_update = ctrl['eta'] * reward_mat - ctrl['lambda'] * A_gated
    if t % 30 == 0 and t>0:
        A_update[malicious_idx, :] -= audit_strength * np.abs(A_update[malicious_idx, :])
    A = A_gated + A_update
    A = np.maximum(A, 0.0)
    np.fill_diagonal(A, 0.0)
    energy = energy_of_A(A); S_val = compute_S(b_new)
    utility = w_S * S_val - w_energy * energy
    records.append({'t': t, 'S': S_val, 'energy': energy, 'utility': utility,
                    'avg_A': A.mean(), 'eta': ctrl['eta'], 'lambda': ctrl['lambda'], 'gate_topk': ctrl['gate_topk']})
    # ---------- ES adaptive controller (تجربة قصيرة لعدة مرشحين) ----------
    if (t+1) % intervene_every == 0 and t>0:
        cand_params=[]; cand_scores=[]
        for k in range(es_population):
            cand={'eta': max(0.0, ctrl['eta'] + np.random.normal(0, es_sigma['eta'])),
                  'lambda': max(1e-6, ctrl['lambda'] + np.random.normal(0, es_sigma['lambda'])),
                  'gate_topk': max(1.0, ctrl['gate_topk'] + np.random.normal(0, es_sigma['gate_topk']))}
            # probe rollout (قصير)
            A_probe = A.copy(); b_probe = b_new.copy(); probe_score = 0.0
            for p in range(probe_steps):
                A_p_g = apply_gating(A_probe, int(round(cand['gate_topk'])))
                I_p = aggregate_inputs(A_p_g, b_probe)
                if (t + p) % 30 == 0:
                    mal_influence = (A_p_g.T[:, malicious_idx].sum(axis=1) * 0.16)
                    I_p = I_p + mal_influence * (np.mean(b_probe[malicious_idx]) * -0.36)
                b_pnew = update_states(b_probe, I_p, alpha, noise_sigma)
                local_gain_p = np.tanh(np.abs(b_pnew - b_probe))
                sim_mat_p = 1.0 - np.abs(b_probe[:, None] - b_probe[None, :])
                sim_mat_p = np.clip(sim_mat_p, 0.0, 1.0)
                reward_mat_p = sim_mat_p * local_gain_p[None, :]
                A_update_p = cand['eta'] * reward_mat_p - cand['lambda'] * A_p_g
                if (t + p) % 30 == 0:
                    A_update_p[malicious_idx, :] -= audit_strength * np.abs(A_update_p[malicious_idx, :])
                A_probe = np.maximum(A_p_g + A_update_p, 0.0); np.fill_diagonal(A_probe, 0.0)
                energy_p = energy_of_A(A_probe); S_p = compute_S(b_pnew)
                probe_score += (w_S * S_p - w_energy * energy_p)
                b_probe = b_pnew
            cand_params.append(cand); cand_scores.append(probe_score)
        best_idx = int(np.argmax(cand_scores)); best_cand = cand_params[best_idx]
        move_frac = 0.5
        ctrl['eta'] = ctrl['eta']*(1-move_frac) + best_cand['eta']*move_frac
        ctrl['lambda'] = ctrl['lambda']*(1-move_frac) + best_cand['lambda']*move_frac
        ctrl['gate_topk'] = ctrl['gate_topk']*(1-move_frac) + best_cand['gate_topk']*move_frac
    b = b_new.copy()

# ---------- حفظ النتائج ورسمها ----------
df = pd.DataFrame(records)
fname = 'attention_es_large_results.csv'
df.to_csv(fname, index=False)
print("Saved metrics to", fname)
plt.figure(figsize=(10,3)); plt.plot(df['t'], df['S']); plt.title('S (cohesion)'); plt.show()
plt.figure(figsize=(10,3)); plt.plot(df['t'], df['energy']); plt.title('Energy'); plt.show()
plt.figure(figsize=(10,3)); plt.plot(df['t'], df['utility']); plt.title('Utility'); plt.show()
plt.figure(figsize=(10,3)); plt.plot(df['t'], df['eta'], label='eta'); plt.plot(df['t'], df['lambda'], label='lambda'); plt.plot(df['t'], df['gate_topk'], label='gate_topk'); plt.legend(); plt.show()