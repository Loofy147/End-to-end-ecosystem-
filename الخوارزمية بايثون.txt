import random
import numpy as np

class GeneticAlgorithm:
    def __init__(self, fitness_func, chromosome_length, population_size=50,
                 generations=100, crossover_rate=0.8, mutation_rate=0.02,
                 elitism=True):
        self.fitness_func = fitness_func
        self.chromosome_length = chromosome_length
        self.population_size = population_size
        self.generations = generations
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.elitism = elitism

    def _initialize_population(self):
        return np.random.uniform(-10, 10, (self.population_size, self.chromosome_length))

    def _evaluate_population(self, population):
        return np.array([self.fitness_func(ind) for ind in population])

    def _select_parent(self, population, fitness):
        # اختيار بالـ roulette wheel
        total_fitness = np.sum(fitness)
        if total_fitness == 0:
            return population[random.randint(0, len(population)-1)]
        pick = random.uniform(0, total_fitness)
        current = 0
        for ind, fit in zip(population, fitness):
            current += fit
            if current > pick:
                return ind
        return population[-1]

    def _crossover(self, parent1, parent2):
        if random.random() > self.crossover_rate:
            return parent1.copy(), parent2.copy()
        point = random.randint(1, self.chromosome_length-1)
        child1 = np.concatenate((parent1[:point], parent2[point:]))
        child2 = np.concatenate((parent2[:point], parent1[point:]))
        return child1, child2

    def _mutate(self, chromosome):
        for i in range(len(chromosome)):
            if random.random() < self.mutation_rate:
                chromosome[i] += np.random.normal(0, 1)  # طفرة Gaussian
        return chromosome

    def run(self):
        population = self._initialize_population()
        best_solution = None
        best_fitness = -float("inf")

        for gen in range(self.generations):
            fitness = self._evaluate_population(population)

            # أفضلية
            if self.elitism:
                elite_idx = np.argmax(fitness)
                elite = population[elite_idx].copy()
                elite_fitness = fitness[elite_idx]

            new_population = []
            while len(new_population) < self.population_size:
                parent1 = self._select_parent(population, fitness)
                parent2 = self._select_parent(population, fitness)
                child1, child2 = self._crossover(parent1, parent2)
                child1 = self._mutate(child1)
                child2 = self._mutate(child2)
                new_population.extend([child1, child2])

            population = np.array(new_population[:self.population_size])

            if self.elitism:
                worst_idx = np.argmin(self._evaluate_population(population))
                population[worst_idx] = elite

            # تحديث الأفضل
            gen_best_idx = np.argmax(fitness)
            if fitness[gen_best_idx] > best_fitness:
                best_fitness = fitness[gen_best_idx]
                best_solution = population[gen_best_idx]

            print(f"Generation {gen+1}/{self.generations} | Best Fitness: {best_fitness:.4f}")

        return best_solution, best_fitness


# ----------- مثال للاستعمال -------------
if __name__ == "__main__":
    # دالة fitness (نريد تعظيمها): f(x) = -(x1^2 + x2^2) + 10
    def fitness_func(chromosome):
        return -np.sum(chromosome**2) + 10

    ga = GeneticAlgorithm(
        fitness_func=fitness_func,
        chromosome_length=2,   # هنا عدد المتغيرات
        population_size=50,
        generations=50,
        crossover_rate=0.8,
        mutation_rate=0.05,
        elitism=True
    )

    best_sol, best_fit = ga.run()
    print("\nأفضل حل:", best_sol)
    print("قيمة Fitness:", best_fit)